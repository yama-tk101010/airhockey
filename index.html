<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Real Neon Air Hockey</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        *, *::before, *::after { box-sizing: border-box; }

        body { 
            margin: 0; padding: 0;
            background-color: #050505; 
            overflow: hidden; 
            height: 100vh; height: 100dvh; 
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            display: flex; justify-content: center; align-items: center;
            touch-action: none; 
            font-family: 'Roboto', sans-serif;
            user-select: none; -webkit-user-select: none; 
            color: white; 
        }
        
        #game-container {
            width: 540px; height: 960px;
            flex-shrink: 0;
            position: relative;
            background: #151515; 
            border: 12px solid #333;
            border-radius: 30px;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            visibility: hidden; 
            transform-origin: center center;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI Overlays */
        #menu, #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        #overlay {
            background: rgba(0,0,0,0.3);
            pointer-events: none;
            opacity: 0;
        }
        #overlay.active { opacity: 1; }

        h1 {
            font-size: 42px; margin: 0 0 10px 0;
            background: linear-gradient(to right, #00d2ff, #ff4757);
            -webkit-background-clip: text; color: transparent;
            font-weight: 900; font-style: italic; letter-spacing: -1px;
            text-transform: uppercase;
        }

        .overlay-text {
            font-size: 80px; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px rgba(255,255,255,0.8), 0 0 50px #00d2ff;
            transform: scale(0.5); transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #overlay.active .overlay-text { transform: scale(1); }
        
        input { 
            font-size: 20px; padding: 15px; margin: 20px 0; text-align: center; width: 70%; 
            border-radius: 12px; border: 2px solid #444; background: #222; color: white; outline: none;
        }
        input:focus { border-color: #00d2ff; }

        button { 
            font-size: 18px; padding: 18px 0; margin: 10px 0; border-radius: 50px; border: none; 
            cursor: pointer; font-weight: bold; width: 80%; color: white;
            box-shadow: 0 6px 20px rgba(0,0,0,0.6); transition: transform 0.1s;
            text-transform: uppercase;
        }
        button:active { transform: scale(0.96); }
        #btn-host { background: linear-gradient(135deg, #00d2ff, #0077aa); }
        #btn-join { background: linear-gradient(135deg, #ff4757, #cc2233); }
        .hidden { opacity: 0; pointer-events: none; }

        #score-board {
            position: absolute; top: 50%; left: 0; width: 100%; transform: translateY(-50%) rotate(-90deg);
            display: flex; justify-content: center; gap: 60px; pointer-events: none; z-index: 5;
            opacity: 0.4;
        }
        .score { 
            font-family: 'Impact', sans-serif; font-size: 140px; 
            color: #fff; text-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        #msg { margin-top:20px; color: #ffeb3b; font-weight:bold; text-align:center; font-size:15px; white-space: pre-wrap; line-height: 1.6; }
        #debug { position: absolute; top: 10px; left: 10px; font-size: 10px; color: #666; pointer-events: none; z-index: 20; font-family: monospace;}
    </style>
</head>
<body>

<div id="game-container">
    <div id="menu">
        <h1>NEON HOCKEY</h1>
        <p style="color:#aaa; margin-top:0; font-size:14px; letter-spacing: 2px;">REALISTIC EDITION</p>
        <input type="text" id="room-id" placeholder="ROOM CODE (例: 777)" autocomplete="off">
        <button id="btn-host" onclick="startHost()">HOST GAME</button>
        <button id="btn-join" onclick="startGuest()">JOIN GAME</button>
        <div id="msg">First to 10 points wins!</div>
    </div>

    <div id="overlay">
        <div id="overlay-msg" class="overlay-text">GOAL!</div>
        <p id="sub-msg" style="color:white; margin-top:20px; font-size:20px; display:none;">Tap to Restart</p>
    </div>

    <div id="score-board">
        <span id="s2" class="score">0</span>
        <span style="font-size:40px; align-self:center; color:#555;">-</span>
        <span id="s1" class="score">0</span>
    </div>

    <div id="debug">Ready</div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    // --- 設定 ---
    const GAME_W = 540;
    const GAME_H = 960;
    const WIN_SCORE = 10; // 10点先取
    
    const PADDLE_R = 50;  // マレットの半径
    const PUCK_R = 32;    // パックの半径
    const FRICTION = 0.99;

    let currentScale = 1;
    let peer, conn;
    let myRole = null; 
    let isConnected = false;
    let isPaused = false; // ゴール演出中のポーズフラグ
    let isGameOver = false;
    const APP_PREFIX = 'y_ah_real_v1_'; 

    const msgEl = document.getElementById('msg');
    const debugEl = document.getElementById('debug');
    const overlayEl = document.getElementById('overlay');
    const overlayMsgEl = document.getElementById('overlay-msg');
    const subMsgEl = document.getElementById('sub-msg');
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const roomInput = document.getElementById('room-id');

    // 合言葉の入力制限
    roomInput.addEventListener('input', function(e) {
        const sanitized = e.target.value.replace(/[^a-zA-Z0-9\-_]/g, '');
        if (e.target.value !== sanitized) e.target.value = sanitized;
    });

    // リアルなテーブル模様の生成（ドット穴）
    let tablePattern = null;
    canvas.width = GAME_W;
    canvas.height = GAME_H;

    function createTablePattern() {
        const pCanvas = document.createElement('canvas');
        pCanvas.width = 40; pCanvas.height = 40;
        const pCtx = pCanvas.getContext('2d');
        // 暗いグレー背景
        pCtx.fillStyle = '#1e2024'; 
        pCtx.fillRect(0, 0, 40, 40);
        // 小さな穴
        pCtx.fillStyle = '#15171a'; 
        pCtx.beginPath(); pCtx.arc(20, 20, 2, 0, Math.PI*2); pCtx.fill();
        tablePattern = ctx.createPattern(pCanvas, 'repeat');
    }
    createTablePattern();

    // --- リサイズ処理 ---
    function resize() {
        const bodyStyle = getComputedStyle(document.body);
        const availableW = window.innerWidth;
        const availableH = window.innerHeight;
        const scaleW = availableW / GAME_W;
        const scaleH = availableH / GAME_H;
        currentScale = Math.min(scaleW, scaleH) * 0.95;
        container.style.transform = `scale(${currentScale})`;
        container.style.visibility = 'visible';
    }
    window.addEventListener('resize', resize);
    setTimeout(resize, 100);

    // --- 通信処理 ---
    function startHost() {
        const roomName = roomInput.value;
        if (!roomName) return alert("合言葉を入力してください");
        setupUI();
        msgEl.innerText = "Creating Room...";
        peer = new Peer(APP_PREFIX + roomName);
        
        peer.on('open', (id) => {
            myRole = 'host';
            msgEl.innerText = "WAITING FOR OPPONENT...";
        });
        peer.on('connection', (c) => {
            conn = c;
            conn.on('open', () => {
                msgEl.innerText = "CONNECTED!";
                setTimeout(startGame, 800);
            });
            conn.on('data', handleData);
        });
        peer.on('error', (err) => { alert("Room Error. Try another code."); location.reload(); });
    }

    function startGuest() {
        const roomName = roomInput.value;
        if (!roomName) return alert("合言葉を入力してください");
        setupUI();
        msgEl.innerText = "Connecting...";
        peer = new Peer(null);
        
        peer.on('open', () => {
            myRole = 'guest';
            conn = peer.connect(APP_PREFIX + roomName);
            conn.on('open', () => {
                msgEl.innerText = "CONNECTED!";
                setTimeout(startGame, 800);
            });
            conn.on('data', handleData);
        });
        peer.on('error', (err) => { msgEl.innerText = "Connection Failed."; document.getElementById('btn-join').disabled = false;});
    }

    function setupUI() {
        document.getElementById('btn-host').disabled = true;
        document.getElementById('btn-join').disabled = true;
    }

    function startGame() {
        isConnected = true;
        document.getElementById('menu').classList.add('hidden');
        if (myRole === 'host') resetPuck();
        loop();
    }
    
    function sendData(data) { if (conn && isConnected) conn.send(data); }

    // --- ゲームロジック ---
    // 色定義: [メイン, ライト, シャドウ, グロー]
    let p1 = { x: GAME_W/2, y: GAME_H - 180, colorHex: '#00d2ff', type: 'p1' }; 
    let p2 = { x: GAME_W/2, y: 180, colorHex: '#ff4757', type: 'p2' };          
    let puck = { x: GAME_W/2, y: GAME_H/2, vx: 0, vy: 0 }; 
    let scores = { p1: 0, p2: 0 };

    function handleData(data) {
        if (data.type === 'syncHost' && myRole === 'guest') {
            // ホストからの同期データ
            p1.x = GAME_W - data.p1.x;
            p1.y = GAME_H - data.p1.y;
            puck.x = GAME_W - data.puck.x;
            puck.y = GAME_H - data.puck.y;
            scores = data.scores;
            updateScoreBoard();
        } 
        else if (data.type === 'syncGuest' && myRole === 'host') {
            // ゲストからの入力データ
            p2.x = GAME_W - data.p2.x;
            p2.y = GAME_H - data.p2.y;
        }
        else if (data.type === 'event') {
            // イベント制御 (GOAL, WINなど)
            handleGameEvent(data);
        }
    }

    function handleGameEvent(evt) {
        if (evt.name === 'goal') {
            showOverlay("GOAL!", evt.winner === 'p2' ? '#ff4757' : '#00d2ff'); // ゲスト視点では色が逆に見えるが、勝者の色を出す
        } else if (evt.name === 'resume') {
            hideOverlay();
        } else if (evt.name === 'gameover') {
            isGameOver = true;
            showOverlay(evt.winner === 'p1' ? "P1 WINS!" : "P2 WINS!", "#fff"); // 簡易表示
            subMsgEl.style.display = "block";
            // ゲスト側のリセット操作を有効化
            container.addEventListener('click', () => location.reload(), {once:true});
        }
    }

    function showOverlay(text, color) {
        overlayMsgEl.innerText = text;
        overlayMsgEl.style.textShadow = `0 0 50px ${color}`;
        overlayEl.classList.add('active');
    }
    function hideOverlay() {
        overlayEl.classList.remove('active');
    }

    function update() {
        if (!isConnected) return;
        
        // ホストのみが物理演算とゲーム進行を担当
        if (myRole === 'host') {
            if (!isPaused && !isGameOver) {
                // 物理演算
                puck.x += puck.vx; puck.y += puck.vy;
                puck.vx *= FRICTION; puck.vy *= FRICTION;
                
                // 壁反射
                if (puck.x < PUCK_R) { puck.x = PUCK_R; puck.vx *= -1; }
                if (puck.x > GAME_W - PUCK_R) { puck.x = GAME_W - PUCK_R; puck.vx *= -1; }
                if (puck.y < PUCK_R) { puck.y = PUCK_R; puck.vy *= -1; }
                if (puck.y > GAME_H - PUCK_R) { puck.y = GAME_H - PUCK_R; puck.vy *= -1; }

                // ゴール判定
                const goalW = GAME_W * 0.45;
                const goalL = (GAME_W - goalW) / 2;
                const goalR = (GAME_W + goalW) / 2;

                if (puck.y <= PUCK_R + 5 && puck.x > goalL && puck.x < goalR) {
                    onGoal('p1'); // 手前(Host)のゴールに入った -> p1の得点 (修正: エアーホッケーは相手ゴールに入れるゲームだが、ここではわかりやすく「入れた人」に加点するロジックにする必要がある。通常: 上壁に入ればP1得点、下壁に入ればP2得点)
                    // 修正: P1(下)が打って上(P2側)に入ればP1得点。
                    // 上の壁(y=0付近)
                } else if (puck.y <= PUCK_R + 5 && (puck.x <= goalL || puck.x >= goalR)) {
                     // 壁に当たっただけ
                     puck.y = PUCK_R; puck.vy *= -1;
                }

                if (puck.y <= PUCK_R + 5 && puck.x > goalL && puck.x < goalR) {
                    // P2側のゴール(上)にP1が入れた -> P1得点
                    scorePoint('p1');
                }
                if (puck.y >= GAME_H - PUCK_R - 5 && puck.x > goalL && puck.x < goalR) {
                    // P1側のゴール(下)にP2が入れた -> P2得点
                    scorePoint('p2');
                }

                checkCollision(p1); 
                checkCollision(p2);
            }

            // データ送信
            sendData({ 
                type: 'syncHost', 
                p1: { x: p1.x, y: p1.y }, 
                puck: { x: puck.x, y: puck.y }, 
                scores: scores 
            });
        } 
        else if (myRole === 'guest') {
            sendData({ type: 'syncGuest', p2: { x: p2.x, y: p2.y } });
        }
    }

    function scorePoint(winner) {
        if (isPaused) return; // 二重計上防止
        
        scores[winner]++;
        isPaused = true;
        updateScoreBoard();
        
        // イベント送信: ゴール
        sendData({ type: 'event', name: 'goal', winner: winner });
        showOverlay("GOAL!", winner === 'p1' ? '#00d2ff' : '#ff4757');

        // 勝利判定
        if (scores[winner] >= WIN_SCORE) {
            isGameOver = true;
            setTimeout(() => {
                let msg = (winner === 'p1') ? "YOU WIN!" : "YOU LOSE";
                showOverlay(msg, "#fff");
                subMsgEl.style.display = "block";
                sendData({ type: 'event', name: 'gameover', winner: winner });
                
                // クリックでリロード
                container.addEventListener('click', () => location.reload(), {once:true});
            }, 1000);
        } else {
            // 次のラウンドへ
            setTimeout(() => {
                resetPuck(winner);
                isPaused = false;
                hideOverlay();
                sendData({ type: 'event', name: 'resume' });
            }, 2000); // 2秒待機
        }
    }

    function checkCollision(paddle) {
        let dx = puck.x - paddle.x;
        let dy = puck.y - paddle.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let minDist = PADDLE_R + PUCK_R;
        
        if (dist < minDist) {
            let angle = Math.atan2(dy, dx);
            let push = minDist - dist;
            
            // 位置補正（めり込み防止）
            puck.x += Math.cos(angle) * push; 
            puck.y += Math.sin(angle) * push;
            
            // 反射ベクトル
            let force = 22; // 反発力を少し強く
            // 速度を加算することで「打つ」感覚を出す
            puck.vx = Math.cos(angle) * force + (puck.x - paddle.x)*0.1;
            puck.vy = Math.sin(angle) * force + (puck.y - paddle.y)*0.1;
            
            // 速度制限
            const MAX_SPEED = 35;
            let speed = Math.sqrt(puck.vx*puck.vx + puck.vy*puck.vy);
            if (speed > MAX_SPEED) {
                puck.vx = (puck.vx / speed) * MAX_SPEED;
                puck.vy = (puck.vy / speed) * MAX_SPEED;
            }
        }
    }

    function resetPuck(winner) {
        puck.x = GAME_W/2; 
        puck.y = GAME_H/2; 
        puck.vx = 0;
        // 点を取られた方に向かってサーブ
        let dir = (winner === 'p1') ? 1 : -1; 
        puck.vy = dir * 8;
    }

    function updateScoreBoard() {
        // ホスト視点: s1=自分(p1), s2=相手(p2)
        // ゲスト視点: s1=相手(p1), s2=自分(p2)
        // ※ここではシンプルに「左がP2(赤)、右がP1(青)」など固定配置にするか、
        // 自分のスコアを常に手前にするか。今回は固定配置（上側P2、下側P1）のスコアを表示
        let scoreP1 = scores.p1;
        let scoreP2 = scores.p2;
        
        // 画面上の配置: 左側(S2)を敵、右側(S1)を自分とする、または上下に対応させる
        // 今回のCSSは transform: rotate(-90deg) しているので、
        // s2(左)が上(P2)、s1(右)が下(P1)に対応します。
        document.getElementById('s1').innerText = scoreP1; // 下側（青）
        document.getElementById('s2').innerText = scoreP2; // 上側（赤）
    }

    // --- 入力処理 ---
    function handleInput(e) {
        if (!isConnected || isGameOver) return;
        e.preventDefault();
        const rect = container.getBoundingClientRect();
        
        let clientX, clientY;
        if(e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX; clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX; clientY = e.clientY;
        }

        let tx = (clientX - rect.left) / currentScale;
        let ty = (clientY - rect.top) / currentScale;

        // パドル位置制限
        if (myRole === 'host') {
            p1.x = tx; 
            p1.y = Math.max(ty, GAME_H/2 + PADDLE_R);
            p1.y = Math.min(p1.y, GAME_H - PADDLE_R);
            p1.x = Math.max(PADDLE_R, Math.min(p1.x, GAME_W - PADDLE_R));
        } else if (myRole === 'guest') {
            p2.x = tx; 
            p2.y = Math.max(ty, GAME_H/2 + PADDLE_R);
            p2.y = Math.min(p2.y, GAME_H - PADDLE_R);
            p2.x = Math.max(PADDLE_R, Math.min(p2.x, GAME_W - PADDLE_R));
        }
    }
    
    canvas.addEventListener('pointermove', handleInput);
    canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture(e.pointerId); handleInput(e); });
    canvas.addEventListener('touchmove', handleInput, {passive: false});
    canvas.addEventListener('touchstart', handleInput, {passive: false});

    // --- リアルな描画 ---
    function draw() {
        // テーブル
        ctx.fillStyle = tablePattern; 
        ctx.fillRect(0,0,GAME_W,GAME_H);
        
        // マーキング（発光するライン）
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#333';
        ctx.shadowBlur = 0;
        
        // センターライン
        ctx.beginPath(); ctx.moveTo(0,GAME_H/2); ctx.lineTo(GAME_W,GAME_H/2); ctx.stroke();
        // センターサークル
        ctx.beginPath(); ctx.arc(GAME_W/2, GAME_H/2, 100, 0, Math.PI*2); ctx.stroke();
        
        // ゴールエリア
        const gw = GAME_W * 0.45;
        // 上ゴールエリア
        ctx.strokeRect((GAME_W-gw)/2, -2, gw, 120);
        ctx.beginPath(); ctx.arc(GAME_W/2, 118, 5, 0, Math.PI*2); ctx.fillStyle="#333"; ctx.fill();
        // 下ゴールエリア
        ctx.strokeRect((GAME_W-gw)/2, GAME_H-118, gw, 120);
        
        // ネオン装飾ライン
        ctx.shadowBlur = 10; ctx.shadowColor = '#00d2ff'; ctx.strokeStyle = 'rgba(0, 210, 255, 0.2)';
        ctx.beginPath(); ctx.arc(GAME_W/2, GAME_H/2, 90, 0, Math.PI*2); ctx.stroke();
        ctx.shadowBlur = 0;

        // ゴール穴
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(0,0,0,1)';
        ctx.fillRect((GAME_W-gw)/2, -20, gw, 40);
        ctx.fillRect((GAME_W-gw)/2, GAME_H-20, gw, 40);
        ctx.shadowBlur = 0;

        // オブジェクト描画
        drawRealisticMallet(p1.x, p1.y, PADDLE_R, '#00d2ff');
        drawRealisticMallet(p2.x, p2.y, PADDLE_R, '#ff4757');
        drawRealisticPuck(puck.x, puck.y, PUCK_R);
    }

    function drawRealisticMallet(x, y, r, colorHex) {
        // 影
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.arc(x, y+10, r, 0, Math.PI*2); ctx.fill();

        // 本体（底面）
        const gradBase = ctx.createRadialGradient(x-r/3, y-r/3, r/4, x, y, r);
        gradBase.addColorStop(0, colorHex);
        gradBase.addColorStop(1, shadeColor(colorHex, -40)); // 暗く
        ctx.fillStyle = gradBase;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        
        // 縁のハイライト
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath(); ctx.arc(x, y, r-2, 0, Math.PI*2); ctx.stroke();

        // 持ち手（ハンドル）部分
        const handleR = r * 0.6;
        const gradHandle = ctx.createRadialGradient(x-handleR/3, y-handleR/3, 5, x, y, handleR);
        gradHandle.addColorStop(0, shadeColor(colorHex, 20)); // 明るく
        gradHandle.addColorStop(1, shadeColor(colorHex, -60)); // かなり暗く
        
        ctx.fillStyle = gradHandle;
        ctx.beginPath(); ctx.arc(x, y, handleR, 0, Math.PI*2); ctx.fill();

        // ハンドルのハイライト
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath(); ctx.arc(x, y, handleR*0.8, 0, Math.PI*2); ctx.fill();
    }

    function drawRealisticPuck(x, y, r) {
        // 影
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); ctx.arc(x, y+6, r, 0, Math.PI*2); ctx.fill();

        // 本体
        const grad = ctx.createRadialGradient(x-r/3, y-r/3, r/10, x, y, r);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.8, '#ccc');
        grad.addColorStop(1, '#999');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

        // 溝デザイン
        ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, r*0.7, 0, Math.PI*2); ctx.stroke();
    }

    // 色を暗く/明るくするヘルパー
    function shadeColor(color, percent) {
        var R = parseInt(color.substring(1,3),16);
        var G = parseInt(color.substring(3,5),16);
        var B = parseInt(color.substring(5,7),16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R<255)?R:255;  
        G = (G<255)?G:255;  
        B = (B<255)?B:255;  

        var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
        var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
        var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

        return "#"+RR+GG+BB;
    }

    function loop() { 
        update(); 
        draw(); 
        if(!isGameOver || isPaused) requestAnimationFrame(loop); 
        // GameOver時はループを止めても良いが、描画維持のため続けるか、フラグで制御
        // 今回はリプレイや残像のため回し続けるがUpdateは止める
    }
</script>
</body>
</html>